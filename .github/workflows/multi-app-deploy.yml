name: Multi-App Deploy to Cloud Foundry (GHE)

# On-demand only — manually triggered from the Actions tab
on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to deploy (e.g., v2.7.0)'
        required: true
        type: string
      deploy_app1:
        description: 'Deploy Application 1'
        required: false
        type: boolean
        default: true
      deploy_app2:
        description: 'Deploy Application 2'
        required: false
        type: boolean
        default: true
      skip_nonprod:
        description: 'Skip non-prod deployment (deploy directly to prod)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  deployments: write

env:
  CF_CLI_VERSION: "v8"

jobs:
  # ──────────────────────────────────────────────────────────────
  # Job 1: Validate release and prepare artifacts
  # ──────────────────────────────────────────────────────────────
  validate-and-prepare:
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.validate.outputs.release_tag }}
      version: ${{ steps.validate.outputs.version }}
      version_dotted: ${{ steps.validate.outputs.version_dotted }}
      deploy_app1: ${{ steps.validate.outputs.deploy_app1 }}
      deploy_app2: ${{ steps.validate.outputs.deploy_app2 }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure GHE Authentication
        env:
          GHE_TOKEN: ${{ secrets.GHE_TOKEN }}
          GHE_HOST: ${{ secrets.GHE_HOST }}
        run: |
          if [ -z "$GHE_HOST" ] || [ -z "$GHE_TOKEN" ]; then
            echo "Error: GHE_HOST and GHE_TOKEN secrets must be configured"
            exit 1
          fi

          # Authenticate gh CLI to GitHub Enterprise Server
          echo "${GHE_TOKEN}" | gh auth login --hostname "${GHE_HOST}" --with-token
          gh auth status --hostname "${GHE_HOST}"
          echo "Authenticated to GitHub Enterprise: ${GHE_HOST}"

      - name: Validate release
        id: validate
        env:
          GH_HOST: ${{ secrets.GHE_HOST }}
          GH_TOKEN: ${{ secrets.GHE_TOKEN }}
          UPSTREAM_REPO: ${{ secrets.APP_UPSTREAM_REPO }}
        run: |
          if [ -z "$UPSTREAM_REPO" ]; then
            echo "Error: APP_UPSTREAM_REPO secret is not set"
            exit 1
          fi

          RELEASE_TAG="${{ inputs.release_tag }}"

          # Validate the release exists on GHE
          echo "Validating release ${RELEASE_TAG} exists in ${UPSTREAM_REPO} on ${GH_HOST}..."
          RELEASE_INFO=$(gh api "repos/${UPSTREAM_REPO}/releases/tags/${RELEASE_TAG}" --jq '.tag_name' 2>&1) || {
            echo "Error: Release ${RELEASE_TAG} not found in ${UPSTREAM_REPO}"
            echo "API response: ${RELEASE_INFO}"
            exit 1
          }
          echo "Release validated: ${RELEASE_INFO}"

          # Check against last deployed version
          LAST_DEPLOYED=""
          if [ -f .last-deployed-version ]; then
            LAST_DEPLOYED=$(cat .last-deployed-version)
          fi

          echo "Last deployed: ${LAST_DEPLOYED:-none}"
          echo "Target release: ${RELEASE_TAG}"

          if [ "$RELEASE_TAG" = "$LAST_DEPLOYED" ]; then
            echo "::warning::Version ${RELEASE_TAG} was previously deployed. Proceeding with re-deployment as requested."
          fi

          VERSION=${RELEASE_TAG#v}
          APP_VERSION=${VERSION//./-}

          echo "release_tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"
          echo "version=${APP_VERSION}" >> "$GITHUB_OUTPUT"
          echo "version_dotted=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "deploy_app1=${{ inputs.deploy_app1 }}" >> "$GITHUB_OUTPUT"
          echo "deploy_app2=${{ inputs.deploy_app2 }}" >> "$GITHUB_OUTPUT"

      - name: Download App 1 release assets
        if: inputs.deploy_app1
        env:
          GH_HOST: ${{ secrets.GHE_HOST }}
          GH_TOKEN: ${{ secrets.GHE_TOKEN }}
          UPSTREAM_REPO: ${{ secrets.APP_UPSTREAM_REPO }}
          APP1_ARTIFACT_PATTERN: ${{ secrets.APP1_ARTIFACT_PATTERN }}
        run: |
          VERSION_DOTTED="${{ steps.validate.outputs.version_dotted }}"

          # Replace {version} placeholder in artifact pattern
          PATTERN=$(echo "${APP1_ARTIFACT_PATTERN}" | sed "s/{version}/${VERSION_DOTTED}/g")
          echo "Downloading App 1 artifact matching: ${PATTERN}"

          mkdir -p ./artifacts/app1
          gh release download "${{ inputs.release_tag }}" \
            --repo "${UPSTREAM_REPO}" \
            --pattern "${PATTERN}" \
            --dir ./artifacts/app1

          echo "App 1 artifacts downloaded:"
          ls -la ./artifacts/app1/

      - name: Download App 2 release assets
        if: inputs.deploy_app2
        env:
          GH_HOST: ${{ secrets.GHE_HOST }}
          GH_TOKEN: ${{ secrets.GHE_TOKEN }}
          UPSTREAM_REPO: ${{ secrets.APP_UPSTREAM_REPO }}
          APP2_ARTIFACT_PATTERN: ${{ secrets.APP2_ARTIFACT_PATTERN }}
        run: |
          VERSION_DOTTED="${{ steps.validate.outputs.version_dotted }}"

          # Replace {version} placeholder in artifact pattern
          PATTERN=$(echo "${APP2_ARTIFACT_PATTERN}" | sed "s/{version}/${VERSION_DOTTED}/g")
          echo "Downloading App 2 artifact matching: ${PATTERN}"

          mkdir -p ./artifacts/app2
          gh release download "${{ inputs.release_tag }}" \
            --repo "${UPSTREAM_REPO}" \
            --pattern "${PATTERN}" \
            --dir ./artifacts/app2

          echo "App 2 artifacts downloaded:"
          ls -la ./artifacts/app2/

      - name: Copy manifest files from repo
        env:
          APP1_MANIFEST: ${{ secrets.APP1_MANIFEST_PATH }}
          APP2_MANIFEST: ${{ secrets.APP2_MANIFEST_PATH }}
        run: |
          # Manifests are stored in this repo, not downloaded from upstream
          if [ "${{ inputs.deploy_app1 }}" = "true" ]; then
            MANIFEST_PATH="${APP1_MANIFEST:-manifests/app1/manifest.yml}"
            if [ ! -f "$MANIFEST_PATH" ]; then
              echo "Error: App 1 manifest not found at ${MANIFEST_PATH}"
              exit 1
            fi
            cp "$MANIFEST_PATH" ./artifacts/app1/manifest.yml
            echo "App 1 manifest copied from: ${MANIFEST_PATH}"
          fi

          if [ "${{ inputs.deploy_app2 }}" = "true" ]; then
            MANIFEST_PATH="${APP2_MANIFEST:-manifests/app2/manifest.yml}"
            if [ ! -f "$MANIFEST_PATH" ]; then
              echo "Error: App 2 manifest not found at ${MANIFEST_PATH}"
              exit 1
            fi
            cp "$MANIFEST_PATH" ./artifacts/app2/manifest.yml
            echo "App 2 manifest copied from: ${MANIFEST_PATH}"
          fi

      - name: Upload App 1 artifacts
        if: inputs.deploy_app1
        uses: actions/upload-artifact@v4
        with:
          name: app1-release-assets
          path: ./artifacts/app1/
          retention-days: 1

      - name: Upload App 2 artifacts
        if: inputs.deploy_app2
        uses: actions/upload-artifact@v4
        with:
          name: app2-release-assets
          path: ./artifacts/app2/
          retention-days: 1

  # ──────────────────────────────────────────────────────────────
  # Job 2: Deploy both apps to Non-Production
  # ──────────────────────────────────────────────────────────────
  deploy-nonprod:
    needs: validate-and-prepare
    if: inputs.skip_nonprod != true
    runs-on: ubuntu-latest
    steps:
      - name: Install CF CLI
        run: |
          curl -sL "https://packages.cloudfoundry.org/stable?release=linux64-binary&version=${{ env.CF_CLI_VERSION }}&source=github" | tar -zx
          chmod +x cf8

      - name: Authenticate to Nonprod CF
        env:
          CF_API: ${{ secrets.CF_NONPROD_API }}
          CF_USER: ${{ secrets.CF_NONPROD_USERNAME }}
          CF_PASS: ${{ secrets.CF_NONPROD_PASSWORD }}
          CF_ORG: ${{ secrets.CF_NONPROD_ORG }}
          CF_SPACE: ${{ secrets.CF_NONPROD_SPACE }}
        run: |
          ./cf8 api "$CF_API"
          ./cf8 auth "$CF_USER" "$CF_PASS"
          ./cf8 target -o "$CF_ORG" -s "$CF_SPACE"
          echo "Authenticated to Nonprod CF: ${CF_API}"

      - name: Download App 1 artifacts
        if: needs.validate-and-prepare.outputs.deploy_app1 == 'true'
        uses: actions/download-artifact@v4
        with:
          name: app1-release-assets
          path: ./app1

      - name: Deploy App 1 to Nonprod
        if: needs.validate-and-prepare.outputs.deploy_app1 == 'true'
        env:
          APP1_NAME: ${{ secrets.APP1_NAME }}
          VERSION: ${{ needs.validate-and-prepare.outputs.version }}
          VERSION_DOTTED: ${{ needs.validate-and-prepare.outputs.version_dotted }}
          APP1_ARTIFACT_PATTERN: ${{ secrets.APP1_ARTIFACT_PATTERN }}
        run: |
          ARTIFACT=$(echo "${APP1_ARTIFACT_PATTERN}" | sed "s/{version}/${VERSION_DOTTED}/g")
          DEPLOY_NAME="${APP1_NAME}-nonprod-${VERSION}"

          echo "Deploying ${DEPLOY_NAME}..."
          ./cf8 push "${DEPLOY_NAME}" \
            -f ./app1/manifest.yml \
            -p "./app1/${ARTIFACT}"

          echo "App 1 deployed to nonprod: ${DEPLOY_NAME}"

      - name: Download App 2 artifacts
        if: needs.validate-and-prepare.outputs.deploy_app2 == 'true'
        uses: actions/download-artifact@v4
        with:
          name: app2-release-assets
          path: ./app2

      - name: Deploy App 2 to Nonprod
        if: needs.validate-and-prepare.outputs.deploy_app2 == 'true'
        env:
          APP2_NAME: ${{ secrets.APP2_NAME }}
          VERSION: ${{ needs.validate-and-prepare.outputs.version }}
          VERSION_DOTTED: ${{ needs.validate-and-prepare.outputs.version_dotted }}
          APP2_ARTIFACT_PATTERN: ${{ secrets.APP2_ARTIFACT_PATTERN }}
        run: |
          ARTIFACT=$(echo "${APP2_ARTIFACT_PATTERN}" | sed "s/{version}/${VERSION_DOTTED}/g")
          DEPLOY_NAME="${APP2_NAME}-nonprod-${VERSION}"

          echo "Deploying ${DEPLOY_NAME}..."
          ./cf8 push "${DEPLOY_NAME}" \
            -f ./app2/manifest.yml \
            -p "./app2/${ARTIFACT}"

          echo "App 2 deployed to nonprod: ${DEPLOY_NAME}"

  # ──────────────────────────────────────────────────────────────
  # Job 3: Send approval notification via GHE
  #
  # GHE automatically emails environment reviewers when the
  # deploy-prod job reaches the 'production' environment gate.
  # This job creates an additional deployment notification for
  # broader visibility (repo watchers, team channels, etc).
  # ──────────────────────────────────────────────────────────────
  notify-approval-required:
    needs: [validate-and-prepare, deploy-nonprod]
    if: |
      always() &&
      (needs.deploy-nonprod.result == 'success' || needs.deploy-nonprod.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Configure GHE Authentication
        env:
          GHE_TOKEN: ${{ secrets.GHE_TOKEN }}
          GHE_HOST: ${{ secrets.GHE_HOST }}
        run: |
          echo "${GHE_TOKEN}" | gh auth login --hostname "${GHE_HOST}" --with-token

      - name: Send deployment approval notification
        env:
          GH_HOST: ${{ secrets.GHE_HOST }}
          GH_TOKEN: ${{ secrets.GHE_TOKEN }}
          APPROVAL_REVIEWERS: ${{ secrets.APPROVAL_REVIEWERS }}
          APP1_NAME: ${{ secrets.APP1_NAME }}
          APP2_NAME: ${{ secrets.APP2_NAME }}
        run: |
          RELEASE_TAG="${{ needs.validate-and-prepare.outputs.release_tag }}"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          DEPLOY_APP1="${{ needs.validate-and-prepare.outputs.deploy_app1 }}"
          DEPLOY_APP2="${{ needs.validate-and-prepare.outputs.deploy_app2 }}"

          # Build description of what's being deployed
          APPS_LIST=""
          if [ "$DEPLOY_APP1" = "true" ]; then APPS_LIST="${APP1_NAME}"; fi
          if [ "$DEPLOY_APP2" = "true" ]; then
            if [ -n "$APPS_LIST" ]; then APPS_LIST="${APPS_LIST}, "; fi
            APPS_LIST="${APPS_LIST}${APP2_NAME}"
          fi

          # Build reviewer mentions for notification
          REVIEWERS_MENTION=""
          if [ -n "$APPROVAL_REVIEWERS" ]; then
            IFS=',' read -ra REVIEWERS <<< "$APPROVAL_REVIEWERS"
            for reviewer in "${REVIEWERS[@]}"; do
              reviewer=$(echo "$reviewer" | xargs)
              REVIEWERS_MENTION="${REVIEWERS_MENTION}@${reviewer} "
            done
          fi

          DESCRIPTION="Production deployment approval required for ${RELEASE_TAG}. Apps: ${APPS_LIST}. Review: ${RUN_URL} ${REVIEWERS_MENTION}"

          echo "=========================================="
          echo "PRODUCTION DEPLOYMENT APPROVAL REQUIRED"
          echo "=========================================="
          echo "Release:    ${RELEASE_TAG}"
          echo "Apps:       ${APPS_LIST}"
          echo "Approve at: ${RUN_URL}"
          echo "Reviewers:  ${APPROVAL_REVIEWERS}"
          echo "=========================================="

          # Create a deployment event via GHE API to trigger email notifications
          # GHE sends emails to repo watchers and mentioned users
          gh api "repos/${{ github.repository }}/deployments" \
            -f ref="${{ github.sha }}" \
            -f environment="production" \
            -f description="${DESCRIPTION}" \
            -f auto_merge=false \
            -f required_contexts="[]" \
            --silent 2>/dev/null || echo "::warning::Could not create deployment notification (non-blocking)"

  # ──────────────────────────────────────────────────────────────
  # Job 4: Deploy both apps to Production
  #
  # Gated by the 'production' environment which requires manual
  # approval. GHE sends email to configured reviewers asking
  # them to approve or reject the deployment.
  #
  # To configure the approval gate:
  #   1. Go to Settings > Environments > New environment > "production"
  #   2. Enable "Required reviewers"
  #   3. Add the users/teams who should approve prod deployments
  #   4. GHE will email those reviewers when this job is reached
  # ──────────────────────────────────────────────────────────────
  deploy-prod:
    needs: [validate-and-prepare, deploy-nonprod]
    if: |
      always() &&
      (needs.deploy-nonprod.result == 'success' || needs.deploy-nonprod.result == 'skipped')
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Install CF CLI
        run: |
          curl -sL "https://packages.cloudfoundry.org/stable?release=linux64-binary&version=${{ env.CF_CLI_VERSION }}&source=github" | tar -zx
          chmod +x cf8

      - name: Authenticate to Prod CF
        env:
          CF_API: ${{ secrets.CF_PROD_API }}
          CF_USER: ${{ secrets.CF_PROD_USERNAME }}
          CF_PASS: ${{ secrets.CF_PROD_PASSWORD }}
          CF_ORG: ${{ secrets.CF_PROD_ORG }}
          CF_SPACE: ${{ secrets.CF_PROD_SPACE }}
        run: |
          ./cf8 api "$CF_API"
          ./cf8 auth "$CF_USER" "$CF_PASS"
          ./cf8 target -o "$CF_ORG" -s "$CF_SPACE"
          echo "Authenticated to Prod CF: ${CF_API}"

      - name: Download App 1 artifacts
        if: needs.validate-and-prepare.outputs.deploy_app1 == 'true'
        uses: actions/download-artifact@v4
        with:
          name: app1-release-assets
          path: ./app1

      - name: Deploy App 1 to Prod
        if: needs.validate-and-prepare.outputs.deploy_app1 == 'true'
        env:
          APP1_NAME: ${{ secrets.APP1_NAME }}
          VERSION: ${{ needs.validate-and-prepare.outputs.version }}
          VERSION_DOTTED: ${{ needs.validate-and-prepare.outputs.version_dotted }}
          APP1_ARTIFACT_PATTERN: ${{ secrets.APP1_ARTIFACT_PATTERN }}
        run: |
          ARTIFACT=$(echo "${APP1_ARTIFACT_PATTERN}" | sed "s/{version}/${VERSION_DOTTED}/g")
          DEPLOY_NAME="${APP1_NAME}-prod-${VERSION}"

          echo "Deploying ${DEPLOY_NAME}..."
          ./cf8 push "${DEPLOY_NAME}" \
            -f ./app1/manifest.yml \
            -p "./app1/${ARTIFACT}"

          echo "App 1 deployed to prod: ${DEPLOY_NAME}"

      - name: Download App 2 artifacts
        if: needs.validate-and-prepare.outputs.deploy_app2 == 'true'
        uses: actions/download-artifact@v4
        with:
          name: app2-release-assets
          path: ./app2

      - name: Deploy App 2 to Prod
        if: needs.validate-and-prepare.outputs.deploy_app2 == 'true'
        env:
          APP2_NAME: ${{ secrets.APP2_NAME }}
          VERSION: ${{ needs.validate-and-prepare.outputs.version }}
          VERSION_DOTTED: ${{ needs.validate-and-prepare.outputs.version_dotted }}
          APP2_ARTIFACT_PATTERN: ${{ secrets.APP2_ARTIFACT_PATTERN }}
        run: |
          ARTIFACT=$(echo "${APP2_ARTIFACT_PATTERN}" | sed "s/{version}/${VERSION_DOTTED}/g")
          DEPLOY_NAME="${APP2_NAME}-prod-${VERSION}"

          echo "Deploying ${DEPLOY_NAME}..."
          ./cf8 push "${DEPLOY_NAME}" \
            -f ./app2/manifest.yml \
            -p "./app2/${ARTIFACT}"

          echo "App 2 deployed to prod: ${DEPLOY_NAME}"

      - name: Configure GHE Authentication for git push
        env:
          GHE_TOKEN: ${{ secrets.GHE_TOKEN }}
          GHE_HOST: ${{ secrets.GHE_HOST }}
        run: |
          # Configure git to use GHE token for push
          git remote set-url origin "https://x-access-token:${GHE_TOKEN}@${GHE_HOST}/${{ github.repository }}.git"

      - name: Record deployed version
        run: |
          echo "${{ needs.validate-and-prepare.outputs.release_tag }}" > .last-deployed-version
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .last-deployed-version
          git diff --cached --quiet || git commit -m "Record deployment of ${{ needs.validate-and-prepare.outputs.release_tag }}"
          git push
